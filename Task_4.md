# Что такое тест-дизайн?
"Тест-дизайн -  один из первоначальных этапов тестирования программного обеспечения, этап планирования и проектирования тестов. 

Тест дизайн представляет собой продумывание и 
написание тестовых случаев (test case), в соответствии 
с требованиями проекта, критериями качества будущего 
продукта и финальными целями тестирования.
Цели тест дизайна:
1. Придумать тесты, которые обнаружат наиболее серьезные ошибки 
продукта. Да, мы можем придумывать тесты, которые находят 
несерьезные ошибки, но тогда тестирование будет неэффективным.
2. Минимизировать количество тестов, необходимых для нахождения большинства серьезных ошибок. Мы может придумать столько тестов, сколько не в состоянии будем выполнить. Поэтому перед разработчиками тестов всегда стоит задача – сохранить эффективность тестов (то есть их способность обнаруживать серьезные ошибки) без увеличения их числа.
Задачи тест-дизайна:
1. Проанализировать требования к продукту
2. Оценить риски возможные при использовании продукта
3. Написать достаточное минимальное количество тестов
4. Разграничить тесты на приемочные, критические, расширенные"

# Для чего нужны техники тест дизайна?
Техники тест-дизайна - это рекомендации, советы и правила, по которым стоит разрабатывать тест для проведения тестирования приложения. Это не образцы тестов, а только рекомендации к применению. В частности различные инженеры могут работая под одним и тем же проектом создать различный набор тестов. Правильным будет считаться тот набор тестов, который за меньшее количество проверок обеспечит более полное покрытие тестами. 
1. Эквивалентное разделение (Equivalence Partitioning - EP).
2. Анализ граничных значений (Boundary Value Analysis - BVA).
3. Предугадывание ошибки (Error Guessing - EG).
4. Исчерпывающее тестирование (Exhaustive Testing - ET).
5. Причина/Следствие (Cause/Effect-CE)
6. Таблица принятия решений (Decision table).
7. Тестирование состояний и переходов (State - transition testing).
8. Метод парного тестирования (Pairwise testing)
# "Какие знаете техники черного ящика? Опишите их.
1. __Эквивалентное разбиение__ - тестирование методом черного ящика, в котором тестовые условия представлены эквивалентными областями, проверяемыми на одном представителе каждой области.
Суть техники эквивалентного разбиения в том, чтобы:
Разделить данные на группы (классы эквивалентности), которые, как предполагается, обрабатываются системой схожим образом (то есть ведут систему к одному состоянию);
Из каждой группы (класса) выбрать одно значение и проверить его.
Цель:
Сократить количество тестов, сохранив тестовое покрытие.

Класс эквивалентности (Equivalence class) – это набор входных (или выходных) данных, которые обрабатываются программой по одному алгоритму или приводят к одному результату.
В чем заключается метод разбиения на классы эквивалентности?
Если все работает правильно, мы считаем, что для всех других эквивалентных значений все будет работать правильно. И наоборот. 

Классы эквивалентности могут быть:

Линейные - упорядоченное множество на числовой прямой (цифры)
Нелинейные - неупорядоченное множество данных, не имеющих граничных значений (буквы, спецсимволы, валюта и др)
Валидные - допустимые значения исходя из требований, позитивные тесты
Невалидные - недопустимые значения, негативные тесты


2. __Граничные значения  (Boundary Value Analysis)__ — это те места, в которых один класс эквивалентности переходит в другой.
Алгоритм использования техники граничных значений:
выделить классы эквивалентности
определить граничные значения этих классов
понять, к какому классу будет относиться каждая граница
провести тесты по проверке значения до границы, на границе и сразу после границы.

Все классы эквивалентности делятся на 3 типа:
Класс, который имеет нижнюю и верхнюю границы 
Класс, который имеет только нижнюю границу 
Класс, который имеет только верхнюю границу 


3. __Тестирование состояний и переходов (State transition testing)__ - изучает, как система переходит из одного состояния в другое в ответ на события.
Состояния — это различные условия (или режимы), в которых может находиться система. Определенные события вызывают («триггерят») переходы, т.е.  перемещения между этими состояниями.
Схематически подобную методику отображают в форме кругов(прямоугольников) и стрелочек, где:
Кружочки, прямоугольники — это текущее состояние объекта;
Стрелочки — ситуация, событие или процесс, благодаря которым объект может двигаться из стадии А в стадию В. Это своего рода действие, которое может выполнятся как пользователем, так и системой.

Таким образом, диаграммы состояний и переходов помогают нам выявлять потенциальные дефекты, проверять правильность переходов между состояниями, и гарантировать, что программное обеспечение работает так, как задумано его создателями, и соответствует требованиям.
Использование подобных схем позволяет наглядным образом визуально оценивать, какие переходы может выполнить ПО и что нужно протестировать в первую очередь.

Диаграммы переходов состояний служат основой для разработки тест-кейсов и изучения поведения нашего программного обеспечения. Стрелочки в данном случае — это уже сформированные тест-кейсы, которые и нужно проверять! А состояние к которому приводит переход  - это ожидаемый результат!

4. __Тестирование по сценариям использования (Use case testing)__
Это подход, при котором система тестируется на основе реальных пользовательских сценариев, которые описывают, как люди взаимодействуют с программой. Тестировщики создают пошаговые инструкции для сценариев, начиная с момента входа в систему до выполнения конкретной задачи.
Основная цель
Цель этого типа тестирования — убедиться, что каждая функциональная часть программы работает так, как ожидается в реальных условиях. Тестирование по сценариям помогает обнаружить проблемы, которые могут возникнуть в процессе обычного использования, а не только в отдельных функциональных тестах.
Пример сценария использования
Например, пользователь хочет купить товар в интернет-магазине. Сценарий может включать поиск товара, добавление его в корзину, ввод информации для оплаты, подтверждение заказа, получение подтверждения на email. Этот сценарий тестируется от начала до конца.
# Комбинаторные техники
__Попарное тестирование (Pairwise)__ - техника тест-дизайна методом черного ящика, при которой тест-кейсы создаются таким образом, чтобы выполнить все возможные отдельные комбинации каждой пары входных параметров.

Метод попарного тестирования базируется на гипотезе, что подавляющее большинство дефектов ПО возникает, когда взаимодействуют два входных параметра. Следовательно, надо проверить не все возможные комбинации параметров, а только такой набор комбинаций, в котором каждая пара параметров встретится хотя бы раз. Таким образом, техника попарного тестирования позволяет значительно сэкономить на количестве тестов.

Преимущества: Эффективное использование ресурсов, Повышение качества продукта, Сокращение времени до выхода на рынок, Снижение рисков
Недостатки: Недостаточное покрытие, Сложность выбора параметров, Необходимость автоматизации

__Техника базового выбора (Base Choice)__
Техника базового выбора (Base Choice) — одна из комбинаторных техник тест-дизайна, которая ориентирована на выбор базового набора тестовых значений для каждой переменной, а затем создание тестовых случаев путем изменения только одной переменной за раз, оставляя остальные на базовом уровне.
Основные шаги:
Определение базового набора значений: Для каждой входной переменной выбирается ""базовое"" значение. Это значение обычно выбирается как наиболее типичное или наименее рискованное.
Создание тестового случая для базового набора: Создается один тестовый случай, который использует базовые значения для всех входных переменных.
Варьирование значений: Для каждой входной переменной создается отдельный тестовый случай, в котором эта переменная принимает одно из своих альтернативных значений, в то время как все остальные переменные остаются на базовом уровне.

__Тестирование каждого выбора  (EC - Each choice testing)__
Определение:
эта стратегия требует, чтобы каждое значение каждого параметра было включено по крайней мере в один тестовый пример (Ammann & Offutt, 1994). Это также определение 1-wise coverage.
Плюсы: легкость применения.
Минусы: минимальное покрытие.
Пример:
В магазине бытовой техники планируют продавать товары следующих категорий: холодильники, морозильные камеры стиральные и сушильные машины. Доступны следующие бренды: Haier, Lg, Bosch, Hotpoint, Indesit, Leran и Atlant. Также существует возможность выбора способа доставки: самовывоз, доставка.

__Тестирование с помощью ортогональных массивов (Orthogonal array testing, OAT)__
Ортогональный массив (ортогональная таблица) - это таблица, обладающая следующими свойствами:
Любые два столбца таблицы содержат все комбинации значений этих столбцов.
Если какая-либо пара значений двух столбцов встречается несколько раз, то все возможные парные комбинации значений этих столбцов должны встретиться столько же раз.
Т.е. в отличие от механизма all pairs, в основе которого лежит фокус на том, чтобы каждая возможная пара значений для двух параметров была проверена хотя бы один раз, ортогональные массивы обеспечивают более равномерное и полное покрытие. Количество тестов может быть больше, чем в попарном тестировании, но все равно значительно меньше, чем при полном переборе всех возможных комбинаций. 

# Тестирование таблицы решений (Decision table testing)
Тестирование таблицы решений — это метод тестирования программного обеспечения, используемый для проверки поведения системы при различных комбинациях входных данных.

Таблица решений представляет собой табличное представление входных данных в сравнении с правилами/случаями/условиями тестирования.

Цель тестирования по этой методике — повысить общее тестовое покрытие, не упуская все (возможные) комбинации.

Таблица решений — это двухмерная матрица, в которой есть четыре компонента: Заголовок условия (condition stub), Заголовок действия (action stub), Условие (condition entry), и Действие (action entry).

# Техника причина/следствие (Cause/Effect – CE) 
Этот метод используется в тестировании для определения комбинаций условий (причин), которые могут привести к определенному результату (следствию) в системе. 
Проще говоря, это простая проверка базовых действий и их результата. 
# Исчерпывающее тестирование
Это метод, применяемый при разработке ПО, который обеспечивает проверку всех возможных комбинаций в наборе данных. Данный вид тестирования используется для гарантии того, что программа не выйдет из строя ни при каких обстоятельствах. Исчерпывающее тестирование относится к дисциплине, отвечающей за качество продукта.
# Техники основанные на опыте

1) __Техника предугадывания ошибок__ 
Предугадывание ошибки (Error Guessing - EG)
Метод проектирования тестов, когда опыт тестировщика используется для предугадывания того, какие дефекты могут быть в тестируемом компоненте или системе в результате сделанных ошибок, а также для разработки тестов специально для их выявления. (ISTQB)
Это одна из методик тестирования программного обеспечения, основанная на опыте и интуиции тестировщика. Техника не требует строгих формальных правил и документации, но предполагает наличие у тестировщика знания системы и понимания того, где и как могут возникнуть ошибки. Она основывается на опыте предыдущих тестирований и знаниях о типичных ошибках, которые часто возникают в подобных системах или в аналогичных ситуациях


2) __Исследовательское тестирование (Exploratory testing – ET)__ 
По ISTQB исследовательское тестирование – это неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, и использует полученную во время тестирования информацию для для проектирования новых и улучшенных тестов.


3) __Тестирование на основе чек-листов (чит-листов)__
Чек-лист — это список, содержащий ряд необходимых проверок для какой-либо работы. 
Каким бы опытным ни был сотрудник, в спешке он может легко забыть важную деталь. 
В тестировании чек-лист — это список проверок для тестирования продукта. 
Чек-лист устроен предельно просто. Любой из них содержит перечень блоков, секций, страниц, других элементов, которые следует протестировать.
Преимущества использования чек-листов:

улучшается представление о системе в целом, виден статус её готовности;
виден объём проделанной и предстоящей работы по тестированию;
легче не повторяться в проверках и не упустить ничего важного в процессе тестирования.

Можно выделить два вида чек-листов: специальные и универсальные.

Специальные чек-листы создаются и используются для конкретных проектов, поэтому его пункты соответствуют специфике проекта. Тестировщик по специальному чек-листу проверяет возможность выполнения уникального действия, предусмотренного требованиями. Такие чек-листы не подходят к использованию на других проектах.

Универсальные чек-листы подходят для тестирования проектов одного типа. Проверка по универсальному чек-листу не привязывается к графическим элементам или конкретной реализации. Проверяется сама возможность пользователя выполнить действие. Для универсального чек-листа составляется абстрактный список проверок.
Универсальные чек-листы можно использовать повторно на проектах одного типа.
# Какие знаете техники белого ящика? Опишите их.
"Тестирование белого ящика — это метод тестирования программного обеспечения, при котором тестировщики имеют доступ к исходному коду и могут использовать его для создания тестов. Основная цель — проверить внутреннюю логику и структуру программы. 
- Основные методы тестирования белого ящика включают:
	- __Покрытие операторов (statement coverage)__ 
Оператор — это любая отдельная команда в программе, которая выполняет определенное действие. Это может быть присвоение значения переменной, ввод/вывод данных, вызов функции и так далее.
Покрытие операторов: означает, что мы пишем тесты таким образом, чтобы каждый оператор в программе был выполнен хотя бы один раз.
Определение: Покрытие операторов измеряет, какие операторы программы были выполнены хотя бы один раз в ходе тестирования. Это базовый уровень покрытия кода, который помогает убедиться, что каждая строка кода была проверена хотя бы один раз.

Покрытие операторов позволяет найти:

Неиспользованные выражения (Unused Statements);
Мертвый код (Dead Code);
Неиспользуемые ветви (Unused Branches);
Недостающие операторы (Missing Statements);
- __Покрытие решений (decision coverage)__ 
Решения — это логические конструкции, которые выбирают один из нескольких возможных путей выполнения программы в зависимости от условий. Наиболее распространенными примерами решений являются операторы if, else if и else, а также switch-выражения. 
Покрытие решений: это тестирование программы таким образом, чтобы каждая ветвь решения была выполнена хотя бы один раз. Другими словами, нужно протестировать и истинную ветвь (например, P > 100), и ложную (например, P <= 100).

Как проводятся тесты покрытия решений?
Каждая строка программы должна пройти через тестирование покрытия решений, чтобы найти любые потенциальные потоки принятия решений в кодах. Хорошо известно, что этот этап тестирования кода имеет решающее значение для процесса создания программ и разработки приложений. Пропуск этого этапа может серьезно снизить эффективность программы в этом модуле.

- __Покрытие условий (condition coverage)__
Условия —  это логическое выражение, которое возвращает либо true (истина), либо false (ложь). Условия используются в решениях для определения, какой путь выполнения программы выбрать.

Покрытие условий: это тестирование таким образом, чтобы каждая часть сложного условия (каждое подусловие) была проверена на истинность и ложность независимо от других частей условия.

Тестирование покрытия условий — это тип тестирования «белого ящика», который проверяет все условные выражения в программе для всех возможных результатов условий. Его также называют покрытием предикатов .
Оно гарантирует, что тестирование включает выполнение обеих ветвей в решении, как оператор if. Если точка принятия решения имеет разные условия (используя AND или OR), покрытие условий гарантирует, что мы протестировали все различные комбинации условий.

Как работает покрытие условий?

Определение точек принятия решений : первым шагом является определение точек принятия решений в коде, обычно представленных условными операторами, такими как if, else if, и else.
Анализ условий : Каждая точка принятия решения может содержать несколько условий, которые оцениваются для определения пути выполнения. Важно проанализировать эти условия и разбить их на более простые компоненты, чтобы обеспечить комплексное тестирование.

Создание тестовых случаев : Тестовые случаи создаются для покрытия обоих возможных результатов каждого условия – true и false. Это гарантирует, что все ветви кода будут проверены во время тестирования.
Выполнение тестов и генерация отчетов : выполняется тестовый набор и генерируется отчет о покрытии для оценки степени достигнутого покрытия условий. Отчет выделяет протестированные и непроверенные условия, что облегчает дальнейшее уточнение тестовых случаев."

